
.. _program_listing_file_include_shad_core_unordered_set.h:

Program Listing for File unordered_set.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_shad_core_unordered_set.h>` (``include/shad/core/unordered_set.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //===------------------------------------------------------------*- C++ -*-===//
   //
   //                                     SHAD
   //
   //      The Scalable High-performance Algorithms and Data Structure Library
   //
   //===----------------------------------------------------------------------===//
   //
   // Copyright 2018 Battelle Memorial Institute
   //
   // Licensed under the Apache License, Version 2.0 (the "License"); you may not
   // use this file except in compliance with the License. You may obtain a copy
   // of the License at
   //
   //     http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   // License for the specific language governing permissions and limitations
   // under the License.
   //
   //===----------------------------------------------------------------------===//
   
   #ifndef INCLUDE_SHAD_CORE_UNORDERED_SET_H_
   #define INCLUDE_SHAD_CORE_UNORDERED_SET_H_
   
   #include <algorithm>
   
   #include "shad/core/iterator.h"
   #include "shad/data_structures/compare_and_hash_utils.h"
   #include "shad/data_structures/set.h"
   
   namespace shad {
   
   template <class Key, class Hash = shad::hash<Key>>
   class unordered_set {
     using set_t = Set<Key>;
   
     friend class insert_iterator<unordered_set>;
     friend class buffered_insert_iterator<unordered_set>;
   
    public:
     using key_type = Key;
     using value_type = typename set_t::value_type;
     using size_type = std::size_t;
     using difference_type = std::ptrdiff_t;
     // todo hasher
     // todo key_equal
     // todo allocator_type
     // todo reference
     // todo const_reference
     using pointer = value_type *;
     using const_pointer = const value_type *;
     using iterator = typename set_t::iterator;
     using const_iterator = typename set_t::const_iterator;
     using local_iterator = typename set_t::local_iterator;
     using const_local_iterator = typename set_t::const_local_iterator;
     // todo node_type
     // todo insert_return_type
   
    public:
     explicit unordered_set(size_type bucket_count = 1021,
                            const Hash &hash = Hash()) {
       ptr = set_t::Create(bucket_count);
     }
   
     ~unordered_set() { set_t::Destroy(ptr.get()->GetGlobalID()); }
   
     // todo assignment
     // todo get_allocator
   
     iterator begin() noexcept { return impl()->begin(); }
     const_iterator begin() const noexcept { return impl()->begin(); }
     const_iterator cbegin() const noexcept { return impl()->cbegin(); }
     iterator end() noexcept { return impl()->end(); }
     const_iterator end() const noexcept { return impl()->end(); }
     const_iterator cend() const noexcept { return impl()->cend(); }
   
     bool empty() const noexcept { return size() == 0; }
     size_type size() const noexcept { return impl()->Size(); }
     // todo max_size
   
     std::pair<iterator, bool> insert(const value_type &value) {
       return impl()->insert(value);
     }
   
     iterator insert(const_iterator hint, const value_type &value) {
       return impl()->insert(hint, value).first;
     }
   
   
   
   
   
   
   
   
   
    private:
     using internal_container_t = set_t;
     using oid_t = typename internal_container_t::ObjectID;
     oid_t global_id() { return impl()->GetGlobalID(); }
     static internal_container_t *from_global_id(oid_t oid) {
       return internal_container_t::GetPtr(oid).get();
     }
   
     std::shared_ptr<set_t> ptr = nullptr;
     const set_t *impl() const { return ptr.get(); }
     set_t *impl() { return ptr.get(); }
   };
   
   // todo operator==
   // todo operator!=
   // todo std::swap
   
   }  // namespace shad
   
   #endif /* INCLUDE_SHAD_CORE_UNORDERED_SET_H_ */
