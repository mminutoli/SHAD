
.. _program_listing_file_include_shad_runtime_handle.h:

Program Listing for File handle.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_shad_runtime_handle.h>` (``include/shad/runtime/handle.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //===------------------------------------------------------------*- C++ -*-===//
   //
   //                                     SHAD
   //
   //      The Scalable High-performance Algorithms and Data Structure Library
   //
   //===----------------------------------------------------------------------===//
   //
   // Copyright 2018 Battelle Memorial Institute
   //
   // Licensed under the Apache License, Version 2.0 (the "License"); you may not
   // use this file except in compliance with the License. You may obtain a copy
   // of the License at
   //
   //     http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   // WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   // License for the specific language governing permissions and limitations
   // under the License.
   //
   //===----------------------------------------------------------------------===//
   
   #ifndef INCLUDE_SHAD_RUNTIME_HANDLE_H_
   #define INCLUDE_SHAD_RUNTIME_HANDLE_H_
   
   #include <type_traits>
   
   #include "shad/config/config.h"
   #include "shad/runtime/mapping_traits.h"
   #include "shad/runtime/mappings/available_traits_mappings.h"
   
   namespace shad {
   
   namespace rt {
   
   namespace impl {
   template <typename TargetSystemTag>
   class AsynchronousInterface;
   }
   
   class Handle {
    public:
     Handle() {
       impl::HandleTrait<TargetSystemTag>::Init(
           id_, impl::HandleTrait<TargetSystemTag>::NullValue());
     }
   
     explicit Handle(typename impl::HandleTrait<TargetSystemTag>::HandleTy id) {
       impl::HandleTrait<TargetSystemTag>::Init(id_, id);
     }
   
     Handle(const Handle &rhs) = default;
   
     Handle(Handle &&rhs) = default;
   
     Handle &operator=(const Handle &rhs) = default;
   
     Handle &operator=(Handle &&rhs) = default;
   
     friend bool operator==(const Handle &lhs, const Handle &rhs) {
       return impl::HandleTrait<TargetSystemTag>::Equal(lhs.id_, rhs.id_);
     }
   
     explicit operator uint64_t() const {
       return impl::HandleTrait<TargetSystemTag>::toUnsignedInt(id_);
     }
   
     bool IsNull() const {
       return id_ == impl::HandleTrait<TargetSystemTag>::NullValue();
     }
   
    private:
     friend void waitForCompletion(Handle &handle);
     friend class impl::AsynchronousInterface<TargetSystemTag>;
     using HandleTy = typename impl::HandleTrait<TargetSystemTag>::HandleTy;
     HandleTy id_;
   };
   
   }  // namespace rt
   }  // namespace shad
   
   #endif  // INCLUDE_SHAD_RUNTIME_HANDLE_H_
